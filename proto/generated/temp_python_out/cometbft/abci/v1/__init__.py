# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: cometbft/abci/v1/service.proto, cometbft/abci/v1/types.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ...crypto import v1 as __crypto_v1__
from types import v1 as __types_v1__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class CheckTxType(betterproto.Enum):
    """
    Type of the transaction check request.

     This enumeration is incompatible with the CheckTxType definition in
     cometbft.abci.v1beta1 and therefore shall not be used in encoding with the same
     field number.
    """

    UNKNOWN = 0
    """Unknown"""

    RECHECK = 1
    """Recheck (2nd, 3rd, etc.)"""

    CHECK = 2
    """Check (1st time)"""


class OfferSnapshotResult(betterproto.Enum):
    """The result of offering a snapshot."""

    UNKNOWN = 0
    """Unknown result, abort all snapshot restoration"""

    ACCEPT = 1
    """Snapshot accepted, apply chunks"""

    ABORT = 2
    """Abort all snapshot restoration"""

    REJECT = 3
    """Reject this specific snapshot, try others"""

    REJECT_FORMAT = 4
    """Reject all snapshots of this format, try others"""

    REJECT_SENDER = 5
    """Reject all snapshots from the sender(s), try others"""


class ApplySnapshotChunkResult(betterproto.Enum):
    """The result of applying a snapshot chunk."""

    UNKNOWN = 0
    """Unknown result, abort all snapshot restoration"""

    ACCEPT = 1
    """Chunk successfully accepted"""

    ABORT = 2
    """Abort all snapshot restoration"""

    RETRY = 3
    """Retry chunk (combine with refetch and reject)"""

    RETRY_SNAPSHOT = 4
    """Retry snapshot (combine with refetch and reject)"""

    REJECT_SNAPSHOT = 5
    """Reject this snapshot, try others"""


class ProcessProposalStatus(betterproto.Enum):
    """ProcessProposalStatus is the status of the proposal processing."""

    UNKNOWN = 0
    """Unknown"""

    ACCEPT = 1
    """Accepted"""

    REJECT = 2
    """Rejected"""


class VerifyVoteExtensionStatus(betterproto.Enum):
    """
    VerifyVoteExtensionStatus is the status of the vote extension verification.
    """

    UNKNOWN = 0
    """Unknown"""

    ACCEPT = 1
    """Accepted"""

    REJECT = 2
    """
    Rejecting the vote extension will reject the entire precommit by the sender.
     Incorrectly implementing this thus has liveness implications as it may affect
     CometBFT's ability to receive 2/3+ valid votes to finalize the block.
     Honest nodes should never be rejected.
    """


class MisbehaviorType(betterproto.Enum):
    """The type of misbehavior committed by a validator."""

    UNKNOWN = 0
    """Unknown"""

    DUPLICATE_VOTE = 1
    """Duplicate vote"""

    LIGHT_CLIENT_ATTACK = 2
    """Light client attack"""


@dataclass(eq=False, repr=False)
class Request(betterproto.Message):
    """Request represents a request to the ABCI application."""

    echo: "EchoRequest" = betterproto.message_field(1, group="value")
    flush: "FlushRequest" = betterproto.message_field(2, group="value")
    info: "InfoRequest" = betterproto.message_field(3, group="value")
    init_chain: "InitChainRequest" = betterproto.message_field(5, group="value")
    query: "QueryRequest" = betterproto.message_field(6, group="value")
    check_tx: "CheckTxRequest" = betterproto.message_field(8, group="value")
    commit: "CommitRequest" = betterproto.message_field(11, group="value")
    list_snapshots: "ListSnapshotsRequest" = betterproto.message_field(
        12, group="value"
    )
    offer_snapshot: "OfferSnapshotRequest" = betterproto.message_field(
        13, group="value"
    )
    load_snapshot_chunk: "LoadSnapshotChunkRequest" = betterproto.message_field(
        14, group="value"
    )
    apply_snapshot_chunk: "ApplySnapshotChunkRequest" = betterproto.message_field(
        15, group="value"
    )
    prepare_proposal: "PrepareProposalRequest" = betterproto.message_field(
        16, group="value"
    )
    process_proposal: "ProcessProposalRequest" = betterproto.message_field(
        17, group="value"
    )
    extend_vote: "ExtendVoteRequest" = betterproto.message_field(18, group="value")
    verify_vote_extension: "VerifyVoteExtensionRequest" = betterproto.message_field(
        19, group="value"
    )
    finalize_block: "FinalizeBlockRequest" = betterproto.message_field(
        20, group="value"
    )


@dataclass(eq=False, repr=False)
class EchoRequest(betterproto.Message):
    """EchoRequest is a request to "echo" the given string."""

    message: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class FlushRequest(betterproto.Message):
    """FlushRequest is a request to flush the write buffer."""

    pass


@dataclass(eq=False, repr=False)
class InfoRequest(betterproto.Message):
    """InfoRequest is a request for the ABCI application version."""

    version: str = betterproto.string_field(1)
    block_version: int = betterproto.uint64_field(2)
    p2_p_version: int = betterproto.uint64_field(3)
    abci_version: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class InitChainRequest(betterproto.Message):
    """InitChainRequest is a request to initialize the blockchain."""

    time: datetime = betterproto.message_field(1)
    chain_id: str = betterproto.string_field(2)
    consensus_params: "__types_v1__.ConsensusParams" = betterproto.message_field(3)
    validators: List["ValidatorUpdate"] = betterproto.message_field(4)
    app_state_bytes: bytes = betterproto.bytes_field(5)
    initial_height: int = betterproto.int64_field(6)


@dataclass(eq=False, repr=False)
class QueryRequest(betterproto.Message):
    """QueryRequest is a request to query the application state."""

    data: bytes = betterproto.bytes_field(1)
    path: str = betterproto.string_field(2)
    height: int = betterproto.int64_field(3)
    prove: bool = betterproto.bool_field(4)


@dataclass(eq=False, repr=False)
class CheckTxRequest(betterproto.Message):
    """CheckTxRequest is a request to check that the transaction is valid."""

    tx: bytes = betterproto.bytes_field(1)
    type: "CheckTxType" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class CommitRequest(betterproto.Message):
    """CommitRequest is a request to commit the pending application state."""

    pass


@dataclass(eq=False, repr=False)
class ListSnapshotsRequest(betterproto.Message):
    """Request to list available snapshots."""

    pass


@dataclass(eq=False, repr=False)
class OfferSnapshotRequest(betterproto.Message):
    """Request offering a snapshot to the application."""

    snapshot: "Snapshot" = betterproto.message_field(1)
    app_hash: bytes = betterproto.bytes_field(2)


@dataclass(eq=False, repr=False)
class LoadSnapshotChunkRequest(betterproto.Message):
    """Request to load a snapshot chunk."""

    height: int = betterproto.uint64_field(1)
    format: int = betterproto.uint32_field(2)
    chunk: int = betterproto.uint32_field(3)


@dataclass(eq=False, repr=False)
class ApplySnapshotChunkRequest(betterproto.Message):
    """Request to apply a snapshot chunk."""

    index: int = betterproto.uint32_field(1)
    chunk: bytes = betterproto.bytes_field(2)
    sender: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class PrepareProposalRequest(betterproto.Message):
    """
    PrepareProposalRequest is a request for the ABCI application to prepare a new
     block proposal.
    """

    max_tx_bytes: int = betterproto.int64_field(1)
    """the modified transactions cannot exceed this size."""

    txs: List[bytes] = betterproto.bytes_field(2)
    """
    txs is an array of transactions that will be included in a block,
     sent to the app for possible modifications.
    """

    local_last_commit: "ExtendedCommitInfo" = betterproto.message_field(3)
    misbehavior: List["Misbehavior"] = betterproto.message_field(4)
    height: int = betterproto.int64_field(5)
    time: datetime = betterproto.message_field(6)
    next_validators_hash: bytes = betterproto.bytes_field(7)
    proposer_address: bytes = betterproto.bytes_field(8)
    """address of the public key of the validator proposing the block."""


@dataclass(eq=False, repr=False)
class ProcessProposalRequest(betterproto.Message):
    """
    ProcessProposalRequest is a request for the ABCI application to process a proposal
     received from another validator.
    """

    txs: List[bytes] = betterproto.bytes_field(1)
    proposed_last_commit: "CommitInfo" = betterproto.message_field(2)
    misbehavior: List["Misbehavior"] = betterproto.message_field(3)
    hash: bytes = betterproto.bytes_field(4)
    """Merkle root hash of the fields of the proposed block."""

    height: int = betterproto.int64_field(5)
    time: datetime = betterproto.message_field(6)
    next_validators_hash: bytes = betterproto.bytes_field(7)
    proposer_address: bytes = betterproto.bytes_field(8)
    """address of the public key of the original proposer of the block."""


@dataclass(eq=False, repr=False)
class ExtendVoteRequest(betterproto.Message):
    """
    ExtendVoteRequest extends a precommit vote with application-injected data.
    """

    hash: bytes = betterproto.bytes_field(1)
    """the hash of the block that this vote may be referring to"""

    height: int = betterproto.int64_field(2)
    """the height of the extended vote"""

    time: datetime = betterproto.message_field(3)
    """info of the block that this vote may be referring to"""

    txs: List[bytes] = betterproto.bytes_field(4)
    proposed_last_commit: "CommitInfo" = betterproto.message_field(5)
    misbehavior: List["Misbehavior"] = betterproto.message_field(6)
    next_validators_hash: bytes = betterproto.bytes_field(7)
    proposer_address: bytes = betterproto.bytes_field(8)
    """address of the public key of the original proposer of the block."""


@dataclass(eq=False, repr=False)
class VerifyVoteExtensionRequest(betterproto.Message):
    """
    VerifyVoteExtensionRequest is a request for the application to verify a vote extension
     produced by a different validator.
    """

    hash: bytes = betterproto.bytes_field(1)
    """the hash of the block that this received vote corresponds to"""

    validator_address: bytes = betterproto.bytes_field(2)
    """the validator that signed the vote extension"""

    height: int = betterproto.int64_field(3)
    vote_extension: bytes = betterproto.bytes_field(4)


@dataclass(eq=False, repr=False)
class FinalizeBlockRequest(betterproto.Message):
    """FinalizeBlockRequest is a request to finalize the block."""

    txs: List[bytes] = betterproto.bytes_field(1)
    decided_last_commit: "CommitInfo" = betterproto.message_field(2)
    misbehavior: List["Misbehavior"] = betterproto.message_field(3)
    hash: bytes = betterproto.bytes_field(4)
    """Merkle root hash of the fields of the decided block."""

    height: int = betterproto.int64_field(5)
    time: datetime = betterproto.message_field(6)
    next_validators_hash: bytes = betterproto.bytes_field(7)
    proposer_address: bytes = betterproto.bytes_field(8)
    """address of the public key of the original proposer of the block."""

    syncing_to_height: int = betterproto.int64_field(9)
    """
    If the node is syncing/replaying blocks - target height. If not, syncing_to == height.
    """


@dataclass(eq=False, repr=False)
class Response(betterproto.Message):
    """Response represents a response from the ABCI application."""

    exception: "ExceptionResponse" = betterproto.message_field(1, group="value")
    echo: "EchoResponse" = betterproto.message_field(2, group="value")
    flush: "FlushResponse" = betterproto.message_field(3, group="value")
    info: "InfoResponse" = betterproto.message_field(4, group="value")
    init_chain: "InitChainResponse" = betterproto.message_field(6, group="value")
    query: "QueryResponse" = betterproto.message_field(7, group="value")
    check_tx: "CheckTxResponse" = betterproto.message_field(9, group="value")
    commit: "CommitResponse" = betterproto.message_field(12, group="value")
    list_snapshots: "ListSnapshotsResponse" = betterproto.message_field(
        13, group="value"
    )
    offer_snapshot: "OfferSnapshotResponse" = betterproto.message_field(
        14, group="value"
    )
    load_snapshot_chunk: "LoadSnapshotChunkResponse" = betterproto.message_field(
        15, group="value"
    )
    apply_snapshot_chunk: "ApplySnapshotChunkResponse" = betterproto.message_field(
        16, group="value"
    )
    prepare_proposal: "PrepareProposalResponse" = betterproto.message_field(
        17, group="value"
    )
    process_proposal: "ProcessProposalResponse" = betterproto.message_field(
        18, group="value"
    )
    extend_vote: "ExtendVoteResponse" = betterproto.message_field(19, group="value")
    verify_vote_extension: "VerifyVoteExtensionResponse" = betterproto.message_field(
        20, group="value"
    )
    finalize_block: "FinalizeBlockResponse" = betterproto.message_field(
        21, group="value"
    )


@dataclass(eq=False, repr=False)
class ExceptionResponse(betterproto.Message):
    """nondeterministic"""

    error: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class EchoResponse(betterproto.Message):
    """EchoResponse indicates that the connection is still alive."""

    message: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class FlushResponse(betterproto.Message):
    """FlushResponse indicates that the write buffer was flushed."""

    pass


@dataclass(eq=False, repr=False)
class InfoResponse(betterproto.Message):
    """InfoResponse contains the ABCI application version information."""

    data: str = betterproto.string_field(1)
    version: str = betterproto.string_field(2)
    app_version: int = betterproto.uint64_field(3)
    last_block_height: int = betterproto.int64_field(4)
    last_block_app_hash: bytes = betterproto.bytes_field(5)


@dataclass(eq=False, repr=False)
class InitChainResponse(betterproto.Message):
    """
    InitChainResponse contains the ABCI application's hash and updates to the
     validator set and/or the consensus params, if any.
    """

    consensus_params: "__types_v1__.ConsensusParams" = betterproto.message_field(1)
    validators: List["ValidatorUpdate"] = betterproto.message_field(2)
    app_hash: bytes = betterproto.bytes_field(3)


@dataclass(eq=False, repr=False)
class QueryResponse(betterproto.Message):
    """QueryResponse contains the ABCI application data along with a proof."""

    code: int = betterproto.uint32_field(1)
    log: str = betterproto.string_field(3)
    """bytes data = 2; // use "value" instead."""

    info: str = betterproto.string_field(4)
    index: int = betterproto.int64_field(5)
    key: bytes = betterproto.bytes_field(6)
    value: bytes = betterproto.bytes_field(7)
    proof_ops: "__crypto_v1__.ProofOps" = betterproto.message_field(8)
    height: int = betterproto.int64_field(9)
    codespace: str = betterproto.string_field(10)


@dataclass(eq=False, repr=False)
class CheckTxResponse(betterproto.Message):
    """
    CheckTxResponse shows if the transaction was deemed valid by the ABCI
     application.
    """

    code: int = betterproto.uint32_field(1)
    data: bytes = betterproto.bytes_field(2)
    log: str = betterproto.string_field(3)
    info: str = betterproto.string_field(4)
    gas_wanted: int = betterproto.int64_field(5)
    gas_used: int = betterproto.int64_field(6)
    events: List["Event"] = betterproto.message_field(7)
    codespace: str = betterproto.string_field(8)


@dataclass(eq=False, repr=False)
class CommitResponse(betterproto.Message):
    """CommitResponse indicates how much blocks should CometBFT retain."""

    retain_height: int = betterproto.int64_field(3)


@dataclass(eq=False, repr=False)
class ListSnapshotsResponse(betterproto.Message):
    """ListSnapshotsResponse contains the list of snapshots."""

    snapshots: List["Snapshot"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class OfferSnapshotResponse(betterproto.Message):
    """
    OfferSnapshotResponse indicates the ABCI application decision whenever to
     provide a snapshot to the requester or not.
    """

    result: "OfferSnapshotResult" = betterproto.enum_field(1)


@dataclass(eq=False, repr=False)
class LoadSnapshotChunkResponse(betterproto.Message):
    """LoadSnapshotChunkResponse returns a snapshot's chunk."""

    chunk: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class ApplySnapshotChunkResponse(betterproto.Message):
    """
    ApplySnapshotChunkResponse returns a result of applying the specified chunk.
    """

    result: "ApplySnapshotChunkResult" = betterproto.enum_field(1)
    refetch_chunks: List[int] = betterproto.uint32_field(2)
    reject_senders: List[str] = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class PrepareProposalResponse(betterproto.Message):
    """
    PrepareProposalResponse contains a list of transactions, which will form a block.
    """

    txs: List[bytes] = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class ProcessProposalResponse(betterproto.Message):
    """
    ProcessProposalResponse indicates the ABCI application's decision whenever
     the given proposal should be accepted or not.
    """

    status: "ProcessProposalStatus" = betterproto.enum_field(1)


@dataclass(eq=False, repr=False)
class ExtendVoteResponse(betterproto.Message):
    """
    ExtendVoteResponse contains the vote extension that the application would like to
     attach to its next precommit vote.
    """

    vote_extension: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class VerifyVoteExtensionResponse(betterproto.Message):
    """
    VerifyVoteExtensionResponse indicates the ABCI application's decision
     whenever the vote extension should be accepted or not.
    """

    status: "VerifyVoteExtensionStatus" = betterproto.enum_field(1)


@dataclass(eq=False, repr=False)
class FinalizeBlockResponse(betterproto.Message):
    """FinalizeBlockResponse contains the result of executing the block."""

    events: List["Event"] = betterproto.message_field(1)
    """set of block events emitted as part of executing the block"""

    tx_results: List["ExecTxResult"] = betterproto.message_field(2)
    """
    the result of executing each transaction including the events
     the particular transaction emitted. This should match the order
     of the transactions delivered in the block itself
    """

    validator_updates: List["ValidatorUpdate"] = betterproto.message_field(3)
    """
    a list of updates to the validator set. These will reflect the validator set at current height + 2.
    """

    consensus_param_updates: "__types_v1__.ConsensusParams" = betterproto.message_field(
        4
    )
    """updates to the consensus params, if any."""

    app_hash: bytes = betterproto.bytes_field(5)
    """
    app_hash is the hash of the applications' state which is used to confirm
     that execution of the transactions was deterministic.
     It is up to the application to decide which algorithm to use.
    """


@dataclass(eq=False, repr=False)
class CommitInfo(betterproto.Message):
    """CommitInfo contains votes for the particular round."""

    round: int = betterproto.int32_field(1)
    votes: List["VoteInfo"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ExtendedCommitInfo(betterproto.Message):
    """
    ExtendedCommitInfo is similar to CommitInfo except that it is only used in
     the PrepareProposal request such that Tendermint can provide vote extensions
     to the application.
    """

    round: int = betterproto.int32_field(1)
    """
    The round at which the block proposer decided in the previous height.
    """

    votes: List["ExtendedVoteInfo"] = betterproto.message_field(2)
    """
    List of validators' addresses in the last validator set with their voting
     information, including vote extensions.
    """


@dataclass(eq=False, repr=False)
class Event(betterproto.Message):
    """
    Event allows application developers to attach additional information to
     ResponseFinalizeBlock and ResponseCheckTx.
     Up to 0.37, this could also be used in ResponseBeginBlock, ResponseEndBlock,
     and ResponseDeliverTx.
     Later, transactions may be queried using these events.
    """

    type: str = betterproto.string_field(1)
    attributes: List["EventAttribute"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class EventAttribute(betterproto.Message):
    """EventAttribute is a single key-value pair, associated with an event."""

    key: str = betterproto.string_field(1)
    value: str = betterproto.string_field(2)
    index: bool = betterproto.bool_field(3)


@dataclass(eq=False, repr=False)
class ExecTxResult(betterproto.Message):
    """
    ExecTxResult contains results of executing one individual transaction.

     * Its structure is equivalent to #ResponseDeliverTx which will be deprecated/deleted
    """

    code: int = betterproto.uint32_field(1)
    data: bytes = betterproto.bytes_field(2)
    log: str = betterproto.string_field(3)
    info: str = betterproto.string_field(4)
    gas_wanted: int = betterproto.int64_field(5)
    gas_used: int = betterproto.int64_field(6)
    events: List["Event"] = betterproto.message_field(7)
    codespace: str = betterproto.string_field(8)


@dataclass(eq=False, repr=False)
class TxResult(betterproto.Message):
    """
    TxResult contains results of executing the transaction.

     One usage is indexing transaction results.
    """

    height: int = betterproto.int64_field(1)
    index: int = betterproto.uint32_field(2)
    tx: bytes = betterproto.bytes_field(3)
    result: "ExecTxResult" = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class Validator(betterproto.Message):
    """Validator in the validator set."""

    address: bytes = betterproto.bytes_field(1)
    power: int = betterproto.int64_field(3)
    """PubKey pub_key = 2 [(gogoproto.nullable)=false];"""


@dataclass(eq=False, repr=False)
class ValidatorUpdate(betterproto.Message):
    """ValidatorUpdate is a singular update to a validator set."""

    power: int = betterproto.int64_field(2)
    pub_key_bytes: bytes = betterproto.bytes_field(3)
    pub_key_type: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class VoteInfo(betterproto.Message):
    """VoteInfo contains the information about the vote."""

    validator: "Validator" = betterproto.message_field(1)
    block_id_flag: "__types_v1__.BlockIdFlag" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class ExtendedVoteInfo(betterproto.Message):
    """
    ExtendedVoteInfo extends VoteInfo with the vote extensions (non-deterministic).
    """

    validator: "Validator" = betterproto.message_field(1)
    """The validator that sent the vote."""

    vote_extension: bytes = betterproto.bytes_field(3)
    """
    Non-deterministic extension provided by the sending validator's application.
    """

    extension_signature: bytes = betterproto.bytes_field(4)
    """Vote extension signature created by CometBFT"""

    block_id_flag: "__types_v1__.BlockIdFlag" = betterproto.enum_field(5)
    """
    block_id_flag indicates whether the validator voted for a block, nil, or did not vote at all
    """


@dataclass(eq=False, repr=False)
class Misbehavior(betterproto.Message):
    """Misbehavior is a type of misbehavior committed by a validator."""

    type: "MisbehaviorType" = betterproto.enum_field(1)
    validator: "Validator" = betterproto.message_field(2)
    """The offending validator"""

    height: int = betterproto.int64_field(3)
    """The height when the offense occurred"""

    time: datetime = betterproto.message_field(4)
    """The corresponding time where the offense occurred"""

    total_voting_power: int = betterproto.int64_field(5)
    """
    Total voting power of the validator set in case the ABCI application does
     not store historical validators.
     https://github.com/tendermint/tendermint/issues/4581
    """


@dataclass(eq=False, repr=False)
class Snapshot(betterproto.Message):
    """Snapshot of the ABCI application state."""

    height: int = betterproto.uint64_field(1)
    format: int = betterproto.uint32_field(2)
    chunks: int = betterproto.uint32_field(3)
    hash: bytes = betterproto.bytes_field(4)
    metadata: bytes = betterproto.bytes_field(5)


class AbciServiceStub(betterproto.ServiceStub):
    async def echo(
        self,
        echo_request: "EchoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EchoResponse":
        return await self._unary_unary(
            "/cometbft.abci.v1.ABCIService/Echo",
            echo_request,
            EchoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def flush(
        self,
        flush_request: "FlushRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "FlushResponse":
        return await self._unary_unary(
            "/cometbft.abci.v1.ABCIService/Flush",
            flush_request,
            FlushResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def info(
        self,
        info_request: "InfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InfoResponse":
        return await self._unary_unary(
            "/cometbft.abci.v1.ABCIService/Info",
            info_request,
            InfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def check_tx(
        self,
        check_tx_request: "CheckTxRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CheckTxResponse":
        return await self._unary_unary(
            "/cometbft.abci.v1.ABCIService/CheckTx",
            check_tx_request,
            CheckTxResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def query(
        self,
        query_request: "QueryRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryResponse":
        return await self._unary_unary(
            "/cometbft.abci.v1.ABCIService/Query",
            query_request,
            QueryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def commit(
        self,
        commit_request: "CommitRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CommitResponse":
        return await self._unary_unary(
            "/cometbft.abci.v1.ABCIService/Commit",
            commit_request,
            CommitResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def init_chain(
        self,
        init_chain_request: "InitChainRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InitChainResponse":
        return await self._unary_unary(
            "/cometbft.abci.v1.ABCIService/InitChain",
            init_chain_request,
            InitChainResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_snapshots(
        self,
        list_snapshots_request: "ListSnapshotsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListSnapshotsResponse":
        return await self._unary_unary(
            "/cometbft.abci.v1.ABCIService/ListSnapshots",
            list_snapshots_request,
            ListSnapshotsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def offer_snapshot(
        self,
        offer_snapshot_request: "OfferSnapshotRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "OfferSnapshotResponse":
        return await self._unary_unary(
            "/cometbft.abci.v1.ABCIService/OfferSnapshot",
            offer_snapshot_request,
            OfferSnapshotResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def load_snapshot_chunk(
        self,
        load_snapshot_chunk_request: "LoadSnapshotChunkRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "LoadSnapshotChunkResponse":
        return await self._unary_unary(
            "/cometbft.abci.v1.ABCIService/LoadSnapshotChunk",
            load_snapshot_chunk_request,
            LoadSnapshotChunkResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def apply_snapshot_chunk(
        self,
        apply_snapshot_chunk_request: "ApplySnapshotChunkRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ApplySnapshotChunkResponse":
        return await self._unary_unary(
            "/cometbft.abci.v1.ABCIService/ApplySnapshotChunk",
            apply_snapshot_chunk_request,
            ApplySnapshotChunkResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def prepare_proposal(
        self,
        prepare_proposal_request: "PrepareProposalRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "PrepareProposalResponse":
        return await self._unary_unary(
            "/cometbft.abci.v1.ABCIService/PrepareProposal",
            prepare_proposal_request,
            PrepareProposalResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def process_proposal(
        self,
        process_proposal_request: "ProcessProposalRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ProcessProposalResponse":
        return await self._unary_unary(
            "/cometbft.abci.v1.ABCIService/ProcessProposal",
            process_proposal_request,
            ProcessProposalResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def extend_vote(
        self,
        extend_vote_request: "ExtendVoteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ExtendVoteResponse":
        return await self._unary_unary(
            "/cometbft.abci.v1.ABCIService/ExtendVote",
            extend_vote_request,
            ExtendVoteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def verify_vote_extension(
        self,
        verify_vote_extension_request: "VerifyVoteExtensionRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "VerifyVoteExtensionResponse":
        return await self._unary_unary(
            "/cometbft.abci.v1.ABCIService/VerifyVoteExtension",
            verify_vote_extension_request,
            VerifyVoteExtensionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def finalize_block(
        self,
        finalize_block_request: "FinalizeBlockRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "FinalizeBlockResponse":
        return await self._unary_unary(
            "/cometbft.abci.v1.ABCIService/FinalizeBlock",
            finalize_block_request,
            FinalizeBlockResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class AbciServiceBase(ServiceBase):

    async def echo(self, echo_request: "EchoRequest") -> "EchoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def flush(self, flush_request: "FlushRequest") -> "FlushResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def info(self, info_request: "InfoRequest") -> "InfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def check_tx(self, check_tx_request: "CheckTxRequest") -> "CheckTxResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def query(self, query_request: "QueryRequest") -> "QueryResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def commit(self, commit_request: "CommitRequest") -> "CommitResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def init_chain(
        self, init_chain_request: "InitChainRequest"
    ) -> "InitChainResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_snapshots(
        self, list_snapshots_request: "ListSnapshotsRequest"
    ) -> "ListSnapshotsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def offer_snapshot(
        self, offer_snapshot_request: "OfferSnapshotRequest"
    ) -> "OfferSnapshotResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def load_snapshot_chunk(
        self, load_snapshot_chunk_request: "LoadSnapshotChunkRequest"
    ) -> "LoadSnapshotChunkResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def apply_snapshot_chunk(
        self, apply_snapshot_chunk_request: "ApplySnapshotChunkRequest"
    ) -> "ApplySnapshotChunkResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def prepare_proposal(
        self, prepare_proposal_request: "PrepareProposalRequest"
    ) -> "PrepareProposalResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def process_proposal(
        self, process_proposal_request: "ProcessProposalRequest"
    ) -> "ProcessProposalResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def extend_vote(
        self, extend_vote_request: "ExtendVoteRequest"
    ) -> "ExtendVoteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def verify_vote_extension(
        self, verify_vote_extension_request: "VerifyVoteExtensionRequest"
    ) -> "VerifyVoteExtensionResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def finalize_block(
        self, finalize_block_request: "FinalizeBlockRequest"
    ) -> "FinalizeBlockResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_echo(
        self, stream: "grpclib.server.Stream[EchoRequest, EchoResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.echo(request)
        await stream.send_message(response)

    async def __rpc_flush(
        self, stream: "grpclib.server.Stream[FlushRequest, FlushResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.flush(request)
        await stream.send_message(response)

    async def __rpc_info(
        self, stream: "grpclib.server.Stream[InfoRequest, InfoResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.info(request)
        await stream.send_message(response)

    async def __rpc_check_tx(
        self, stream: "grpclib.server.Stream[CheckTxRequest, CheckTxResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.check_tx(request)
        await stream.send_message(response)

    async def __rpc_query(
        self, stream: "grpclib.server.Stream[QueryRequest, QueryResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.query(request)
        await stream.send_message(response)

    async def __rpc_commit(
        self, stream: "grpclib.server.Stream[CommitRequest, CommitResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.commit(request)
        await stream.send_message(response)

    async def __rpc_init_chain(
        self, stream: "grpclib.server.Stream[InitChainRequest, InitChainResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.init_chain(request)
        await stream.send_message(response)

    async def __rpc_list_snapshots(
        self,
        stream: "grpclib.server.Stream[ListSnapshotsRequest, ListSnapshotsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_snapshots(request)
        await stream.send_message(response)

    async def __rpc_offer_snapshot(
        self,
        stream: "grpclib.server.Stream[OfferSnapshotRequest, OfferSnapshotResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.offer_snapshot(request)
        await stream.send_message(response)

    async def __rpc_load_snapshot_chunk(
        self,
        stream: "grpclib.server.Stream[LoadSnapshotChunkRequest, LoadSnapshotChunkResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.load_snapshot_chunk(request)
        await stream.send_message(response)

    async def __rpc_apply_snapshot_chunk(
        self,
        stream: "grpclib.server.Stream[ApplySnapshotChunkRequest, ApplySnapshotChunkResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.apply_snapshot_chunk(request)
        await stream.send_message(response)

    async def __rpc_prepare_proposal(
        self,
        stream: "grpclib.server.Stream[PrepareProposalRequest, PrepareProposalResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.prepare_proposal(request)
        await stream.send_message(response)

    async def __rpc_process_proposal(
        self,
        stream: "grpclib.server.Stream[ProcessProposalRequest, ProcessProposalResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.process_proposal(request)
        await stream.send_message(response)

    async def __rpc_extend_vote(
        self, stream: "grpclib.server.Stream[ExtendVoteRequest, ExtendVoteResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.extend_vote(request)
        await stream.send_message(response)

    async def __rpc_verify_vote_extension(
        self,
        stream: "grpclib.server.Stream[VerifyVoteExtensionRequest, VerifyVoteExtensionResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.verify_vote_extension(request)
        await stream.send_message(response)

    async def __rpc_finalize_block(
        self,
        stream: "grpclib.server.Stream[FinalizeBlockRequest, FinalizeBlockResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.finalize_block(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/cometbft.abci.v1.ABCIService/Echo": grpclib.const.Handler(
                self.__rpc_echo,
                grpclib.const.Cardinality.UNARY_UNARY,
                EchoRequest,
                EchoResponse,
            ),
            "/cometbft.abci.v1.ABCIService/Flush": grpclib.const.Handler(
                self.__rpc_flush,
                grpclib.const.Cardinality.UNARY_UNARY,
                FlushRequest,
                FlushResponse,
            ),
            "/cometbft.abci.v1.ABCIService/Info": grpclib.const.Handler(
                self.__rpc_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                InfoRequest,
                InfoResponse,
            ),
            "/cometbft.abci.v1.ABCIService/CheckTx": grpclib.const.Handler(
                self.__rpc_check_tx,
                grpclib.const.Cardinality.UNARY_UNARY,
                CheckTxRequest,
                CheckTxResponse,
            ),
            "/cometbft.abci.v1.ABCIService/Query": grpclib.const.Handler(
                self.__rpc_query,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryRequest,
                QueryResponse,
            ),
            "/cometbft.abci.v1.ABCIService/Commit": grpclib.const.Handler(
                self.__rpc_commit,
                grpclib.const.Cardinality.UNARY_UNARY,
                CommitRequest,
                CommitResponse,
            ),
            "/cometbft.abci.v1.ABCIService/InitChain": grpclib.const.Handler(
                self.__rpc_init_chain,
                grpclib.const.Cardinality.UNARY_UNARY,
                InitChainRequest,
                InitChainResponse,
            ),
            "/cometbft.abci.v1.ABCIService/ListSnapshots": grpclib.const.Handler(
                self.__rpc_list_snapshots,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListSnapshotsRequest,
                ListSnapshotsResponse,
            ),
            "/cometbft.abci.v1.ABCIService/OfferSnapshot": grpclib.const.Handler(
                self.__rpc_offer_snapshot,
                grpclib.const.Cardinality.UNARY_UNARY,
                OfferSnapshotRequest,
                OfferSnapshotResponse,
            ),
            "/cometbft.abci.v1.ABCIService/LoadSnapshotChunk": grpclib.const.Handler(
                self.__rpc_load_snapshot_chunk,
                grpclib.const.Cardinality.UNARY_UNARY,
                LoadSnapshotChunkRequest,
                LoadSnapshotChunkResponse,
            ),
            "/cometbft.abci.v1.ABCIService/ApplySnapshotChunk": grpclib.const.Handler(
                self.__rpc_apply_snapshot_chunk,
                grpclib.const.Cardinality.UNARY_UNARY,
                ApplySnapshotChunkRequest,
                ApplySnapshotChunkResponse,
            ),
            "/cometbft.abci.v1.ABCIService/PrepareProposal": grpclib.const.Handler(
                self.__rpc_prepare_proposal,
                grpclib.const.Cardinality.UNARY_UNARY,
                PrepareProposalRequest,
                PrepareProposalResponse,
            ),
            "/cometbft.abci.v1.ABCIService/ProcessProposal": grpclib.const.Handler(
                self.__rpc_process_proposal,
                grpclib.const.Cardinality.UNARY_UNARY,
                ProcessProposalRequest,
                ProcessProposalResponse,
            ),
            "/cometbft.abci.v1.ABCIService/ExtendVote": grpclib.const.Handler(
                self.__rpc_extend_vote,
                grpclib.const.Cardinality.UNARY_UNARY,
                ExtendVoteRequest,
                ExtendVoteResponse,
            ),
            "/cometbft.abci.v1.ABCIService/VerifyVoteExtension": grpclib.const.Handler(
                self.__rpc_verify_vote_extension,
                grpclib.const.Cardinality.UNARY_UNARY,
                VerifyVoteExtensionRequest,
                VerifyVoteExtensionResponse,
            ),
            "/cometbft.abci.v1.ABCIService/FinalizeBlock": grpclib.const.Handler(
                self.__rpc_finalize_block,
                grpclib.const.Cardinality.UNARY_UNARY,
                FinalizeBlockRequest,
                FinalizeBlockResponse,
            ),
        }
