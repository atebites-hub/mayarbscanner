# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: cometbft/p2p/v1/conn.proto, cometbft/p2p/v1/pex.proto, cometbft/p2p/v1/types.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import List

import betterproto

from ...crypto import v1 as __crypto_v1__


@dataclass(eq=False, repr=False)
class PacketPing(betterproto.Message):
    """PacketPing is a request to confirm that the connection is alive."""

    pass


@dataclass(eq=False, repr=False)
class PacketPong(betterproto.Message):
    """PacketPong is a response to confirm that the connection is alive."""

    pass


@dataclass(eq=False, repr=False)
class PacketMsg(betterproto.Message):
    """
    PacketMsg contains data for the specified channel ID. EOF means the message
     is fully received.
    """

    channel_id: int = betterproto.int32_field(1)
    eof: bool = betterproto.bool_field(2)
    data: bytes = betterproto.bytes_field(3)


@dataclass(eq=False, repr=False)
class Packet(betterproto.Message):
    """Packet is an abstract p2p message."""

    packet_ping: "PacketPing" = betterproto.message_field(1, group="sum")
    packet_pong: "PacketPong" = betterproto.message_field(2, group="sum")
    packet_msg: "PacketMsg" = betterproto.message_field(3, group="sum")


@dataclass(eq=False, repr=False)
class AuthSigMessage(betterproto.Message):
    """
    AuthSigMessage is sent during the authentication and contains our/remote's
     signature along with the public key.
    """

    pub_key: "__crypto_v1__.PublicKey" = betterproto.message_field(1)
    sig: bytes = betterproto.bytes_field(2)


@dataclass(eq=False, repr=False)
class NetAddress(betterproto.Message):
    """NetAddress represents a peer's network address."""

    id: str = betterproto.string_field(1)
    ip: str = betterproto.string_field(2)
    port: int = betterproto.uint32_field(3)


@dataclass(eq=False, repr=False)
class ProtocolVersion(betterproto.Message):
    """ProtocolVersion represents the current p2p protocol version."""

    p2_p: int = betterproto.uint64_field(1)
    block: int = betterproto.uint64_field(2)
    app: int = betterproto.uint64_field(3)


@dataclass(eq=False, repr=False)
class DefaultNodeInfo(betterproto.Message):
    """
    DefaultNodeInfo is a basic node's information sent to other peers during the
     p2p handshake.
    """

    protocol_version: "ProtocolVersion" = betterproto.message_field(1)
    default_node_id: str = betterproto.string_field(2)
    listen_addr: str = betterproto.string_field(3)
    network: str = betterproto.string_field(4)
    version: str = betterproto.string_field(5)
    channels: bytes = betterproto.bytes_field(6)
    moniker: str = betterproto.string_field(7)
    other: "DefaultNodeInfoOther" = betterproto.message_field(8)


@dataclass(eq=False, repr=False)
class DefaultNodeInfoOther(betterproto.Message):
    """DefaultNodeInfoOther is the misc. application specific data."""

    tx_index: str = betterproto.string_field(1)
    rpc_address: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class PexRequest(betterproto.Message):
    """PexRequest is a request for peer addresses."""

    pass


@dataclass(eq=False, repr=False)
class PexAddrs(betterproto.Message):
    """PexAddrs is a response with peer addresses."""

    addrs: List["NetAddress"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class Message(betterproto.Message):
    """Message is an abstract PEX message."""

    pex_request: "PexRequest" = betterproto.message_field(1, group="sum")
    pex_addrs: "PexAddrs" = betterproto.message_field(2, group="sum")
